{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Plugin as VitePlugin, ResolvedConfig, ViteDevServer } from \"vite\";\n\ninterface ChatGPTWidgetPluginOptions {\n  /** Directory containing widget component files. Defaults to \"web/chatgpt-widgets\" */\n  widgetsDir?: string;\n  /**\n   * Base URL for widget assets. Required if Vite's base config is not an absolute URL.\n   * Should include protocol and domain (e.g., \"https://example.com/\").\n   * Used to generate fully qualified URLs for assets in sandboxed iframes.\n   */\n  baseUrl?: string;\n}\n\n/**\n * Widget Helpers for MCP Resource Registration\n *\n * This module provides utilities to discover and serve ChatGPT widget HTML.\n *\n * Architecture:\n * - The Vite plugin (src/vite-chatgpt-app-widget.ts) is the source of truth for HTML structure\n * - In development: We use Vite's pluginContainer to load raw HTML, then transformIndexHtml to process it\n *   This ensures proper asset URL rewriting and transformation through Vite's full HTML pipeline\n * - In production: We read the built HTML files that Vite has already processed with correct asset URLs\n *\n * This ensures that MCP resources always serve exactly what Vite would serve.\n */\nexport interface WidgetInfo {\n  name: string;\n  filePath: string;\n  content: string;\n}\n\n/**\n * Details of where a production Vite build is located\n */\nexport interface ProductionViteBuild {\n  /** Path to the Vite manifest.json file from a production build. */\n  manifestPath: string;\n  /**\n   * Base URL for widget assets. Required if Vite's base config is not an absolute URL.\n   * Should include protocol and domain (e.g., \"https://example.com/\").\n   * Used to generate fully qualified URLs for assets in sandboxed iframes.\n   */\n  baseUrl?: string;\n}\n\nexport type ViteHandle = ViteDevServer | ProductionViteBuild;\n\nconst ROOT_WIDGET_NAME = \"root\";\n\n/**\n * Checks if a URL is absolute (contains a protocol and domain)\n */\nfunction isAbsoluteUrl(url: string): boolean {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Transforms HTML to use absolute URLs for script and link tags\n */\nfunction transformHtmlWithAbsoluteUrls(html: string, baseUrl: string): string {\n  // Ensure baseUrl ends with /\n  const normalizedBase = baseUrl.endsWith(\"/\") ? baseUrl : `${baseUrl}/`;\n\n  // Transform script src attributes\n  html = html.replace(\n    /(<script[^>]+src=[\"'])\\/([^\"']+)([\"'])/g,\n    (match, prefix, path, suffix) => `${prefix}${normalizedBase}${path}${suffix}`\n  );\n\n  // Transform link href attributes (for modulepreload, stylesheets, etc.)\n  html = html.replace(\n    /(<link[^>]+href=[\"'])\\/([^\"']+)([\"'])/g,\n    (match, prefix, path, suffix) => `${prefix}${normalizedBase}${path}${suffix}`\n  );\n\n  return html;\n}\n\n/**\n * Returns all widget files in the given directory, and their file contents\n **/\nexport async function getWidgets(widgetsDir: string, viteHandle: ViteHandle): Promise<WidgetInfo[]> {\n  const widgetsDirPath = path.resolve(process.cwd(), widgetsDir);\n\n  if (!(await exists(widgetsDirPath))) {\n    return [];\n  }\n\n  const files = await listWidgetFiles(widgetsDirPath);\n  const widgets: WidgetInfo[] = [];\n\n  for (const file of files) {\n    widgets.push({\n      name: file.name,\n      filePath: path.join(widgetsDirPath, file.path),\n      content: await getWidgetHTML(file.name, viteHandle),\n    });\n  }\n\n  return widgets;\n}\n\n/**\n * Generates HTML content for a widget to be served via MCP\n *\n * In production: Reads the built HTML file using Vite's manifest.json to find the actual built file path\n * In development: Uses Vite's pluginContainer to load raw HTML, then transformIndexHtml to process it\n *\n * The Vite plugin is the source of truth for the HTML structure.\n */\nexport async function getWidgetHTML(widgetName: string, viteHandle?: ViteHandle): Promise<string> {\n  // Check if this is a ViteDevServer (has pluginContainer)\n  const isViteDevServer = viteHandle && \"pluginContainer\" in viteHandle;\n\n  let html: string;\n  let viteBase: string | undefined;\n  let explicitBaseUrl: string | undefined;\n\n  if (isViteDevServer) {\n    const vite = viteHandle;\n    const virtualModuleId = `virtual:chatgpt-widget-${widgetName}.html`;\n\n    try {\n      // Step 1: Use plugin container to resolve and load the raw HTML from our plugin\n      const resolved = await vite.pluginContainer.resolveId(virtualModuleId);\n      if (!resolved) {\n        throw new Error(`Failed to resolve virtual module: ${virtualModuleId}`);\n      }\n\n      const loaded = await vite.pluginContainer.load(resolved.id);\n      if (!loaded || (typeof loaded === \"string\" ? !loaded : !loaded.code)) {\n        throw new Error(\n          `Vite returned no content for widget '${widgetName}'. ` + `Make sure the widget file exists in web/chatgpt-widgets/`\n        );\n      }\n\n      const rawHtml = typeof loaded === \"string\" ? loaded : loaded.code;\n\n      // Step 2: Transform the HTML through Vite's HTML transformation pipeline\n      // This will process script tags, apply plugins, rewrite asset URLs, etc.\n      // Pass the virtual module ID as the URL so Vite knows the context\n      const transformedHtml = await vite.transformIndexHtml(virtualModuleId, rawHtml);\n\n      // rewrite src=\"virtual:chatgpt-widget-${widgetName}.js\" to src=\"/@id/virtual:chatgpt-widget-${widgetName}.js\"\n      html = transformedHtml.replace(/src=\"virtual:chatgpt-widget-/g, `src=\"/@id/virtual:chatgpt-widget-`);\n\n      // Get base from Vite config\n      viteBase = vite.config.base;\n    } catch (error) {\n      throw new Error(\n        `Failed to load widget '${widgetName}' using Vite. ` + `Error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  } else {\n    // Production: Read the built HTML file using Vite's manifest\n    const options = (viteHandle || {}) as ProductionViteBuild;\n    const manifestPath = path.resolve(process.cwd(), options.manifestPath || \"dist/.vite/manifest.json\");\n\n    // Read the Vite manifest to verify the widget was built\n    if (!(await exists(manifestPath))) {\n      throw new Error(\n        `Vite manifest not found at ${manifestPath}. ` +\n          `Make sure to build with manifest enabled: { build: { manifest: true } } in vite.config.ts`\n      );\n    }\n\n    const manifestContent = await fs.readFile(manifestPath, \"utf-8\");\n    const manifest = JSON.parse(manifestContent) as Record<string, { file: string }>;\n\n    // Look for the widget HTML file in the manifest\n    const virtualModuleId = `virtual:chatgpt-widget-${widgetName}.html`;\n    const manifestEntry = manifest[virtualModuleId];\n\n    if (!manifestEntry) {\n      throw new Error(\n        `Widget '${widgetName}' not found in Vite manifest. ` +\n          `Available entries: ${Object.keys(manifest).join(\", \")}. ` +\n          `Make sure the widget exists and was included in the build.`\n      );\n    }\n\n    // The built HTML file is in the dist root with the virtual module ID as its name\n    // e.g., dist/virtual:chatgpt-widget-TestWidget.html\n    const buildDir = path.dirname(path.dirname(manifestPath)); // Go up from .vite to dist\n    const builtHtmlPath = path.join(buildDir, virtualModuleId);\n\n    if (!(await exists(builtHtmlPath))) {\n      throw new Error(\n        `Built widget HTML not found at ${builtHtmlPath}. ` +\n          `Expected HTML file to be generated during build. This may indicate a build issue.`\n      );\n    }\n\n    // Read the built HTML file\n    html = await fs.readFile(builtHtmlPath, \"utf-8\");\n\n    // Get explicit baseUrl from production options\n    explicitBaseUrl = options.baseUrl;\n\n    // Try to read base from the manifest's parent vite config\n    // In production, we don't have direct access to Vite config, so we rely on explicit baseUrl\n  }\n\n  // Determine the effective base URL for transforming asset links\n  let effectiveBaseUrl: string | undefined;\n\n  if (viteBase && isAbsoluteUrl(viteBase)) {\n    // Vite's base is already absolute, use it\n    effectiveBaseUrl = viteBase;\n  } else if (explicitBaseUrl) {\n    // Use the explicit baseUrl provided\n    effectiveBaseUrl = explicitBaseUrl;\n  }\n\n  // If we have an effective base URL, transform the HTML\n  if (effectiveBaseUrl) {\n    html = transformHtmlWithAbsoluteUrls(html, effectiveBaseUrl);\n  }\n\n  return html;\n}\n\n/**\n * Vite plugin that creates virtual HTML entrypoints for each React component in the widgets directory.\n *\n * For each component file in the widgets directory (e.g., Foo.tsx), this plugin:\n * 1. Creates a virtual HTML file (virtual:chatgpt-widget-Foo.html)\n * 2. Creates a virtual JavaScript entrypoint that imports and renders the component\n * 3. Adds these entrypoints to the Rollup build configuration\n * 4. Produces standalone HTML files that can be embedded as widgets\n *\n * The component files should export a React component as their default export.\n *\n * @example\n * // In web/chatgpt-widgets/MyWidget.tsx\n * export default function MyWidget() {\n *   return <div>Hello World</div>;\n * }\n *\n * // After build, produces:\n * // dist/chatgpt-widget-MyWidget.html\n */\n/**\n * Generates the HTML content for a widget entrypoint\n * This is exported so it can be reused by the MCP resource generator\n *\n * @param widgetName - The name of the widget\n */\nexport function generateWidgetEntrypointHTML(widgetName: string): string {\n  // Always use the virtual: protocol here\n  // In dev mode, the MCP helper will rewrite this to /@id/virtual: after HTML transformation\n  // In build mode, Vite will resolve and bundle this appropriately\n  const jsEntrypoint = `virtual:chatgpt-widget-${widgetName}.js`;\n\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>${widgetName} Widget</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"${jsEntrypoint}\"></script>\n  </body>\n</html>\n  `.trim();\n}\n\nexport function chatGPTWidgetPlugin(options: ChatGPTWidgetPluginOptions = {}): VitePlugin {\n  const widgetsDir = options.widgetsDir || \"web/chatgpt-widgets\";\n  let config: ResolvedConfig;\n  let viteRoot: string;\n\n  return {\n    name: \"vite-chatgpt-widget\",\n\n    config(config) {\n      // Store the root for use in the options hook\n      viteRoot = config.root || process.cwd();\n      return null;\n    },\n\n    configResolved(resolvedConfig: ResolvedConfig) {\n      config = resolvedConfig;\n    },\n\n    async options(options) {\n      // Add widget virtual entrypoints to rollup input during build\n      // Use the root from the config hook\n      const widgetsDirPath = path.resolve(viteRoot || process.cwd(), widgetsDir);\n\n      // Check if the directory exists, if not, return early\n      if (!(await exists(widgetsDirPath))) {\n        return options;\n      }\n\n      const files = await listWidgetFiles(widgetsDirPath);\n      const widgetEntries: Record<string, string> = {};\n\n      for (const file of files) {\n        widgetEntries[`chatgpt-widget-${file.name}`] = `virtual:chatgpt-widget-${file.name}.html`;\n      }\n\n      // Add widget entries to existing input\n      if (Object.keys(widgetEntries).length > 0) {\n        const currentInput = options.input;\n\n        if (typeof currentInput === \"string\") {\n          options.input = { main: currentInput, ...widgetEntries };\n        } else if (Array.isArray(currentInput)) {\n          options.input = [...currentInput, ...Object.values(widgetEntries)];\n        } else if (typeof currentInput === \"object\" && currentInput !== null) {\n          options.input = { ...currentInput, ...widgetEntries };\n        } else {\n          options.input = widgetEntries;\n        }\n      }\n\n      return options;\n    },\n\n    resolveId(id) {\n      // Handle virtual HTML entrypoint resolution\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".html\")) {\n        return id;\n      }\n      // Handle virtual JS entrypoint resolution\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".js\")) {\n        return \"\\0\" + id;\n      }\n      return null;\n    },\n\n    async load(id) {\n      // Handle virtual HTML files\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".html\")) {\n        const widgetName = id.replace(\"virtual:chatgpt-widget-\", \"\").replace(\".html\", \"\");\n        return generateWidgetEntrypointHTML(widgetName);\n      }\n\n      // Handle virtual JS entrypoints\n      if (id.startsWith(\"\\0virtual:chatgpt-widget-\") && id.endsWith(\".js\")) {\n        const widgetName = id.replace(\"\\0virtual:chatgpt-widget-\", \"\").replace(\".js\", \"\");\n\n        // Find the actual widget file\n        const widgetsDirPath = path.resolve(config.root, widgetsDir);\n        const possibleExtensions = [\".tsx\", \".ts\", \".jsx\", \".js\"];\n        let widgetFile = \"\";\n\n        for (const ext of possibleExtensions) {\n          const candidatePath = path.join(widgetsDirPath, `${widgetName}${ext}`);\n          if (await exists(candidatePath)) {\n            widgetFile = `/${widgetsDir}/${widgetName}${ext}`;\n            break;\n          }\n        }\n\n        if (!widgetFile) {\n          this.error(`Widget file not found for: ${widgetName}`);\n          return;\n        }\n\n        // Check if a root layout component exists\n        let rootFile = \"\";\n        for (const ext of possibleExtensions) {\n          const candidatePath = path.join(widgetsDirPath, `root${ext}`);\n          if (await exists(candidatePath)) {\n            rootFile = `/${widgetsDir}/root${ext}`;\n            break;\n          }\n        }\n\n        // Generate the entrypoint with or without root layout wrapper\n        if (rootFile) {\n          return `\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport Widget from '${widgetFile}';\nimport RootLayout from '${rootFile}';\n\nconst container = document.getElementById('root');\nif (!container) {\n  throw new Error('Root element not found');\n}\n\nconst root = createRoot(container);\nroot.render(React.createElement(RootLayout, null, React.createElement(Widget)));\n          `.trim();\n        } else {\n          return `\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport Widget from '${widgetFile}';\n\nconst container = document.getElementById('root');\nif (!container) {\n  throw new Error('Root element not found');\n}\n\nconst root = createRoot(container);\nroot.render(React.createElement(Widget));\n          `.trim();\n        }\n      }\n\n      return null;\n    },\n  };\n}\n\nconst exists = async (path: string) => {\n  try {\n    await fs.stat(path);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nconst listWidgetFiles = async (widgetsDir: string) => {\n  const widgetsDirPath = path.resolve(process.cwd(), widgetsDir);\n  const files = await fs.readdir(widgetsDirPath);\n  const results: {\n    path: string;\n    name: string;\n  }[] = [];\n\n  for (const file of files) {\n    const ext = path.extname(file);\n    if ([\".ts\", \".tsx\", \".js\", \".jsx\"].includes(ext)) {\n      const name = path.basename(file, ext);\n      // Skip root.tsx as it's a layout wrapper, not a widget\n      if (name.toLowerCase() === ROOT_WIDGET_NAME) {\n        continue;\n      }\n\n      results.push({ path: path.join(widgetsDirPath, file), name });\n    }\n  }\n\n  return results;\n};\n"]}