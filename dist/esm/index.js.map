{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport type { Plugin as VitePlugin, ResolvedConfig, ViteDevServer } from \"vite\";\n\ninterface ChatGPTWidgetPluginOptions {\n  /** Directory containing widget component files. Defaults to \"web/chatgpt-widgets\" */\n  widgetsDir?: string;\n}\n\n/**\n * Widget Helpers for MCP Resource Registration\n *\n * This module provides utilities to discover and serve ChatGPT widget HTML.\n *\n * Architecture:\n * - The Vite plugin (src/vite-chatgpt-app-widget.ts) is the source of truth for HTML structure\n * - In development: We use Vite's pluginContainer to load raw HTML, then transformIndexHtml to process it\n *   This ensures proper asset URL rewriting and transformation through Vite's full HTML pipeline\n * - In production: We read the built HTML files that Vite has already processed with correct asset URLs\n *\n * This ensures that MCP resources always serve exactly what Vite would serve.\n */\nexport interface WidgetInfo {\n  name: string;\n  filePath: string;\n  content: string;\n}\n\n/**\n * Details of where a production Vite build is located\n */\nexport interface ProductionViteBuild {\n  /** Path to the Vite manifest.json file from a production build. */\n  manifestPath: string;\n}\n\nexport type ViteHandle = ViteDevServer | ProductionViteBuild;\n/**\n * Returns all widget files in the given directory, and their file contents\n **/\nexport async function getWidgets(widgetsDir: string, viteHandle: ViteHandle): Promise<WidgetInfo[]> {\n  const widgetsDirPath = path.resolve(process.cwd(), widgetsDir);\n\n  if (!(await exists(widgetsDirPath))) {\n    return [];\n  }\n\n  const files = await fs.readdir(widgetsDirPath);\n  const widgets: WidgetInfo[] = [];\n\n  for (const file of files) {\n    const ext = path.extname(file);\n    if ([\".ts\", \".tsx\", \".js\", \".jsx\"].includes(ext)) {\n      const name = path.basename(file, ext);\n      widgets.push({\n        name,\n        filePath: path.join(widgetsDirPath, file),\n        content: await getWidgetHTML(name, viteHandle),\n      });\n    }\n  }\n\n  return widgets;\n}\n\n/**\n * Generates HTML content for a widget to be served via MCP\n *\n * In production: Reads the built HTML file using Vite's manifest.json to find the actual built file path\n * In development: Uses Vite's pluginContainer to load raw HTML, then transformIndexHtml to process it\n *\n * The Vite plugin is the source of truth for the HTML structure.\n */\nexport async function getWidgetHTML(widgetName: string, viteHandle?: ViteHandle): Promise<string> {\n  // Check if this is a ViteDevServer (has pluginContainer)\n  const isViteDevServer = viteHandle && \"pluginContainer\" in viteHandle;\n\n  if (isViteDevServer) {\n    const vite = viteHandle;\n    const virtualModuleId = `virtual:chatgpt-widget-${widgetName}.html`;\n\n    try {\n      // Step 1: Use plugin container to resolve and load the raw HTML from our plugin\n      const resolved = await vite.pluginContainer.resolveId(virtualModuleId);\n      if (!resolved) {\n        throw new Error(`Failed to resolve virtual module: ${virtualModuleId}`);\n      }\n\n      const loaded = await vite.pluginContainer.load(resolved.id);\n      if (!loaded || (typeof loaded === \"string\" ? !loaded : !loaded.code)) {\n        throw new Error(\n          `Vite returned no content for widget '${widgetName}'. ` + `Make sure the widget file exists in web/chatgpt-widgets/`\n        );\n      }\n\n      const rawHtml = typeof loaded === \"string\" ? loaded : loaded.code;\n\n      // Step 2: Transform the HTML through Vite's HTML transformation pipeline\n      // This will process script tags, apply plugins, rewrite asset URLs, etc.\n      // Pass the virtual module ID as the URL so Vite knows the context\n      const transformedHtml = await vite.transformIndexHtml(virtualModuleId, rawHtml);\n\n      // rewrite src=\"virtual:chatgpt-widget-${widgetName}.js\" to src=\"/@id/virtual:chatgpt-widget-${widgetName}.js\"\n      const finalHtml = transformedHtml.replace(/src=\"virtual:chatgpt-widget-/g, `src=\"/@id/virtual:chatgpt-widget-`);\n\n      return finalHtml;\n    } catch (error) {\n      throw new Error(\n        `Failed to load widget '${widgetName}' using Vite. ` + `Error: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // Production: Read the built HTML file using Vite's manifest\n  const options = viteHandle as ProductionViteBuild;\n  const manifestPath = path.resolve(process.cwd(), options.manifestPath || \"dist/.vite/manifest.json\");\n\n  // Read the Vite manifest to verify the widget was built\n  if (!(await exists(manifestPath))) {\n    throw new Error(\n      `Vite manifest not found at ${manifestPath}. ` +\n        `Make sure to build with manifest enabled: { build: { manifest: true } } in vite.config.ts`\n    );\n  }\n\n  const manifestContent = await fs.readFile(manifestPath, \"utf-8\");\n  const manifest = JSON.parse(manifestContent) as Record<string, { file: string }>;\n\n  // Look for the widget HTML file in the manifest\n  const virtualModuleId = `virtual:chatgpt-widget-${widgetName}.html`;\n  const manifestEntry = manifest[virtualModuleId];\n\n  if (!manifestEntry) {\n    throw new Error(\n      `Widget '${widgetName}' not found in Vite manifest. ` +\n        `Available entries: ${Object.keys(manifest).join(\", \")}. ` +\n        `Make sure the widget exists and was included in the build.`\n    );\n  }\n\n  // The built HTML file is in the dist root with the virtual module ID as its name\n  // e.g., dist/virtual:chatgpt-widget-TestWidget.html\n  const buildDir = path.dirname(path.dirname(manifestPath)); // Go up from .vite to dist\n  const builtHtmlPath = path.join(buildDir, virtualModuleId);\n\n  if (!(await exists(builtHtmlPath))) {\n    throw new Error(\n      `Built widget HTML not found at ${builtHtmlPath}. ` +\n        `Expected HTML file to be generated during build. This may indicate a build issue.`\n    );\n  }\n\n  // Read and return the built HTML file\n  // Vite has already processed this and included all the correct asset URLs\n  return await fs.readFile(builtHtmlPath, \"utf-8\");\n}\n\n/**\n * Vite plugin that creates virtual HTML entrypoints for each React component in the widgets directory.\n *\n * For each component file in the widgets directory (e.g., Foo.tsx), this plugin:\n * 1. Creates a virtual HTML file (virtual:chatgpt-widget-Foo.html)\n * 2. Creates a virtual JavaScript entrypoint that imports and renders the component\n * 3. Adds these entrypoints to the Rollup build configuration\n * 4. Produces standalone HTML files that can be embedded as widgets\n *\n * The component files should export a React component as their default export.\n *\n * @example\n * // In web/chatgpt-widgets/MyWidget.tsx\n * export default function MyWidget() {\n *   return <div>Hello World</div>;\n * }\n *\n * // After build, produces:\n * // dist/chatgpt-widget-MyWidget.html\n */\n/**\n * Generates the HTML content for a widget entrypoint\n * This is exported so it can be reused by the MCP resource generator\n *\n * @param widgetName - The name of the widget\n */\nexport function generateWidgetEntrypointHTML(widgetName: string): string {\n  // Always use the virtual: protocol here\n  // In dev mode, the MCP helper will rewrite this to /@id/virtual: after HTML transformation\n  // In build mode, Vite will resolve and bundle this appropriately\n  const jsEntrypoint = `virtual:chatgpt-widget-${widgetName}.js`;\n\n  return `\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>${widgetName} Widget</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"${jsEntrypoint}\"></script>\n  </body>\n</html>\n  `.trim();\n}\n\nexport function chatGPTWidgetPlugin(options: ChatGPTWidgetPluginOptions = {}): VitePlugin {\n  const widgetsDir = options.widgetsDir || \"web/chatgpt-widgets\";\n  let config: ResolvedConfig;\n  let viteRoot: string;\n\n  return {\n    name: \"vite-chatgpt-widget\",\n\n    config(config) {\n      // Store the root for use in the options hook\n      viteRoot = config.root || process.cwd();\n      return null;\n    },\n\n    configResolved(resolvedConfig: ResolvedConfig) {\n      config = resolvedConfig;\n    },\n\n    async options(options) {\n      // Add widget virtual entrypoints to rollup input during build\n      // Use the root from the config hook\n      const widgetsDirPath = path.resolve(viteRoot || process.cwd(), widgetsDir);\n\n      // Check if the directory exists, if not, return early\n      if (!(await exists(widgetsDirPath))) {\n        return options;\n      }\n\n      const files = await fs.readdir(widgetsDirPath);\n      const widgetEntries: Record<string, string> = {};\n\n      for (const file of files) {\n        const ext = path.extname(file);\n        if ([\".ts\", \".tsx\", \".js\", \".jsx\"].includes(ext)) {\n          const basename = path.basename(file, ext);\n          widgetEntries[`chatgpt-widget-${basename}`] = `virtual:chatgpt-widget-${basename}.html`;\n        }\n      }\n\n      // Add widget entries to existing input\n      if (Object.keys(widgetEntries).length > 0) {\n        const currentInput = options.input;\n\n        if (typeof currentInput === \"string\") {\n          options.input = { main: currentInput, ...widgetEntries };\n        } else if (Array.isArray(currentInput)) {\n          options.input = [...currentInput, ...Object.values(widgetEntries)];\n        } else if (typeof currentInput === \"object\" && currentInput !== null) {\n          options.input = { ...currentInput, ...widgetEntries };\n        } else {\n          options.input = widgetEntries;\n        }\n      }\n\n      return options;\n    },\n\n    resolveId(id) {\n      // Handle virtual HTML entrypoint resolution\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".html\")) {\n        return id;\n      }\n      // Handle virtual JS entrypoint resolution\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".js\")) {\n        return \"\\0\" + id;\n      }\n      return null;\n    },\n\n    async load(id) {\n      // Handle virtual HTML files\n      if (id.startsWith(\"virtual:chatgpt-widget-\") && id.endsWith(\".html\")) {\n        const widgetName = id.replace(\"virtual:chatgpt-widget-\", \"\").replace(\".html\", \"\");\n        return generateWidgetEntrypointHTML(widgetName);\n      }\n\n      // Handle virtual JS entrypoints\n      if (id.startsWith(\"\\0virtual:chatgpt-widget-\") && id.endsWith(\".js\")) {\n        const widgetName = id.replace(\"\\0virtual:chatgpt-widget-\", \"\").replace(\".js\", \"\");\n\n        // Find the actual widget file\n        const widgetsDirPath = path.resolve(config.root, widgetsDir);\n        const possibleExtensions = [\".tsx\", \".ts\", \".jsx\", \".js\"];\n        let widgetFile = \"\";\n\n        for (const ext of possibleExtensions) {\n          const candidatePath = path.join(widgetsDirPath, `${widgetName}${ext}`);\n          if (await exists(candidatePath)) {\n            widgetFile = `/${widgetsDir}/${widgetName}${ext}`;\n            break;\n          }\n        }\n\n        if (!widgetFile) {\n          this.error(`Widget file not found for: ${widgetName}`);\n          return;\n        }\n\n        return `\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport Widget from '${widgetFile}';\n\nconst container = document.getElementById('root');\nif (!container) {\n  throw new Error('Root element not found');\n}\n\nconst root = createRoot(container);\nroot.render(React.createElement(Widget));\n        `.trim();\n      }\n\n      return null;\n    },\n  };\n}\n\nconst exists = async (path: string) => {\n  try {\n    await fs.stat(path);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n"]}